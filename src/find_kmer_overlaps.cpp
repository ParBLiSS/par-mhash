#include "bliss-config.hpp"

#include <cstdint>
#include <vector>
#include <string>

#include "io/file.hpp"
#include "io/kmer_parser.hpp"
#include "io/kmer_file_helper.hpp"

#include "mxx/env.hpp"
#include "mxx/comm.hpp"
#include "mxx/utils.hpp"
#include "tclap/CmdLine.h"
#include "utils/tclap_utils.hpp"

#include "run_cfg.hpp"
#include "io_utils.hpp"
template<typename KmerType>
struct ReadsCountParser{
  // type of element generated by this parser.
  using value_type = char;
  using kmer_type = KmerType;
  static constexpr size_t window_size = kmer_type::size;

  bliss::partition::range<std::size_t> valid_range;

  ReadsCountParser(::bliss::partition::range<size_t> const & _valid_range)
    : valid_range(_valid_range) {};

    template <typename SeqType, typename OutputIt>
    OutputIt operator()(SeqType & read, OutputIt output_iter) {

        static_assert(std::is_same< SeqType,
                      bliss::io::FASTQSequence<typename SeqType::IteratorType> >::value,
                      "ReadLengthParser only supports FASTQ at the moment.");

        static_assert(std::is_same<value_type,
                      typename std::iterator_traits<OutputIt>::value_type>::value,
                      "output type and output container value type are not the same");

        // printf("First: pos %lu kmer %s\n", read.id.id,
        //       bliss::utils::KmerUtils::toASCIIString(*start).c_str());

        *output_iter = '1';
        return output_iter;
    }


};



std::size_t getReadsCount(mxx::comm& comm, bliss::io::file_data& file_data){

  std::vector<char> vx;
  bliss::io::KmerFileHelper::template
    parse_file_data<ReadsCountParser<KmerType>, FileParser,
                    SeqIterType>(file_data, vx, comm);

  return vx.size();
}



void parse_args(int argc, char **argv,
                mxx::comm& comm,
                std::string& positionFile,
                std::vector<std::string>& filenames,
                std::string& outPrefix,
                uint32_t& threshold){
  try { // try-catch block for commandline

    TCLAP::CmdLine cmd("Overlap Graph Construction", ' ', "0.1");

    // MPI friendly commandline output.
    bliss::utils::tclap::MPIOutput cmd_output(comm);
    cmd.setOutput(&cmd_output);

   // position file argument
    TCLAP::ValueArg<std::string> positionArg("p", "position_file",
                                             "Position for input file (full path)",
                                             true, "", "string", cmd);



    // output file argument
    TCLAP::ValueArg<std::string> outputArg("O", "output_prefix",
                                           "Prefix for output files, including directory",
                                           false, "", "string", cmd);

    // threshold argument
    TCLAP::ValueArg<uint32_t> threshArg("d", "overlap_threshold",
                                          "Threshold for Overlap",
                                          false, 20, "int", cmd);

    // input files
    TCLAP::UnlabeledMultiArg<std::string> fileArg("filenames", "FASTA or FASTQ file names",
                                                  true, "string", cmd);


    // Parse the argv array.
    cmd.parse( argc, argv );

    positionFile = positionArg.getValue();
    outPrefix = outputArg.getValue();
    filenames = fileArg.getValue();
    threshold = threshArg.getValue();

    if(comm.rank() == 0){
      std::cout << "--------------------------------------" << std::endl;
      std::cout << "Position File   : " << positionFile << std::endl;
      std::cout << "Output File Pfx : " << outPrefix << std::endl;
      std::cout << "Input File      : " << filenames.front() << std::endl;
      std::cout << "Threshold       : " << threshold << std::endl;
      std::cout << "--------------------------------------" << std::endl;
    }

  } catch (TCLAP::ArgException &e)  {
    std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl;
    exit(-1);
  }
}

template<typename T=uint64_t>
void runKSO(mxx::comm& comm,
            std::string positionFile,
            std::vector<std::string>& inFiles,
            std::string outPrefix,
            uint32_t threshold){
  BL_BENCH_INIT(kfso);
  std::vector<::bliss::io::file_data> file_data;
  size_t total = 0;

  BL_BENCH_START(kfso);
  load_file_data(comm, inFiles, file_data);
  BL_BENCH_COLLECTIVE_END(kfso, "read_files", total, comm);

  BL_BENCH_START(kfso);
  BL_BENCH_COLLECTIVE_END(kfso, "all_pairs", read_pairs.size(), comm);
  BL_BENCH_REPORT_MPI_NAMED(kfso, "kfso_app", comm);
}

int main(int argc, char** argv) {

  LOG_INIT(); // init logging

  mxx::env e(argc, argv); // MPI init
  mxx::comm comm;

  if (comm.rank() == 0)
    std::cout << "EXECUTING " << std::string(argv[0]) << std::endl;


  std::string positionFile;
  std::vector<std::string> filenames;
  std::string outPrefix;
  uint32_t threshold;
  outPrefix.assign("./output");

  // parse arguments
  parse_args(argc, argv, comm,
             positionFile, filenames, outPrefix, threshold);
  if(comm.rank() == 0 && filenames.size() > 0){
    for(auto fx : filenames) std::cout << fx << std::endl;
  }

  comm.barrier();
  auto start = std::chrono::steady_clock::now();

  if(!comm.rank())
      std::cout << "Timer started" << std::endl;

  runKSO(comm, positionFile, filenames, outPrefix, threshold);
  comm.barrier();
  auto end = std::chrono::steady_clock::now();
  auto elapsed_time  = std::chrono::duration<double, std::milli>(end - start).count();

  if(!comm.rank())
      std::cout << "Time (ms) -> " << elapsed_time << std::endl;
}
